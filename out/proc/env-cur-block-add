create or replace procedure Env_CurBlock_Add_tr (
  p_BlockHash  binary(32),
  p_BlockDtm   datetime(0),
  p_Dtm        datetime(3)
)
begin

-- Boilerplate

declare err boolean default false;
declare cont boolean default false;
declare gobble boolean default false;
declare sqlStates varchar(512) default '';
declare sqlCodes varchar(512) default '';
declare msgTxts varchar(512) default '';
declare lastSqlCode smallint default 0;
declare lastMsgTxt varchar(512) default '';

declare continue handler for SQLWarning
begin
  if not gobble then
    get diagnostics @errCount = number;
    set @i = 1;
    while @i <= @errCount do
      get diagnostics condition @i
        @sqlState = returned_sqlstate, @sqlCode = mysql_errno, @msgTxt = message_text;
      set @errstr = concat('Env_CurBlock_Add_tr ', @sqlState, ' ', @sqlCode, ' ', @msgTxt);
      select @sqlState as `SqlState`, @sqlCode as `SqlCode`, @errstr as Warn;
      set @i = @i + 1;
    end while;
  end if;
end;

declare continue handler for SQLException, 1265
begin
  set err = true;
  if not gobble then
    if cont then
      get diagnostics @errCount = number;
      if @errCount >= 1 then
        get diagnostics condition 1
          @sqlState = returned_sqlstate, @sqlCode = mysql_errno, @msgTxt_ = message_text;
        set @msgTxt = concat(@sqlState, ' ', @sqlCode, ' ', @msgTxt_);
        set sqlStates = case when sqlStates = ''
          then @sqlState else concat(sqlStates, ', ', @sqlState) end;
        set sqlCodes = case when sqlCodes = ''
          then @sqlCode else concat(sqlCodes, ', ', @sqlCode) end;
        set msgTxts = case when msgTxts = ''
          then @msgTxt else concat(msgTxts, '\n', @msgTxt) end;
        set @i = 2;
        while @i <= @errCount do
          get diagnostics condition @i
            @sqlState = returned_sqlstate, @sqlCode = mysql_errno, @msgTxt_ = message_text;
          set @msgTxt = concat(@sqlState, ' ', @sqlCode, ' ', @msgTxt_);
          set sqlStates = concat(sqlStates, ', ', @sqlState);
          set sqlCodes = concat(sqlCodes, ', ', @sqlCode);
          set msgTxts = concat(msgTxts, '\n', @msgTxt);
          set @i = @i + 1;
        end while;
      end if;
    else
      get diagnostics condition 1
        @sqlState_ = returned_sqlstate, @sqlCode_ = mysql_errno, @msgTxt = message_text;
      get diagnostics @errCount = number;
      if @errCount >= 2 then
        get diagnostics condition 2
          @sqlState = returned_sqlstate, @sqlCode = mysql_errno, @msgTxt_ = message_text;
        set @msgTxt = concat(@sqlState, ' ', @sqlCode, ' ', @msgTxt_);
        set sqlStates = case when sqlStates = ''
          then @sqlState else concat(sqlStates, ', ', @sqlState) end;
        set sqlCodes = case when sqlCodes = ''
          then @sqlCode else concat(sqlCodes, ', ', @sqlCode) end;
        set msgTxts = case when msgTxts = ''
          then @msgTxt else concat(msgTxts, '\n', @msgTxt) end;
        set @i = 3;
        while @i <= @errCount do
          get diagnostics condition @i
            @sqlState = returned_sqlstate, @sqlCode = mysql_errno, @msgTxt_ = message_text;
          set @msgTxt = concat(@sqlState, ' ', @sqlCode, ' ', @msgTxt_);
          set sqlStates = concat(sqlStates, ', ', @sqlState);
          set sqlCodes = concat(sqlCodes, ', ', @sqlCode);
          set msgTxts = concat(msgTxts, '\n', @msgTxt);
          set @i = @i + 1;
        end while;
      end if;
      if sqlStates <> '' then
        set @sqlState = concat('sqlstate: ', sqlStates);
        set @sqlCode = concat('sqlcode: ', sqlCodes);
        set @errstr = concat(@msgTxt, ' (', @sqlState, '; ', @sqlCode, ')', '\n\n', msgTxts);
      else
        set @errstr = @msgTxt;
      end if;
      set @errstr = concat('Env_CurBlock_Add_tr ', @sqlState_, ' ', @sqlCode_, ' ', @errstr);
      if @@in_transaction then
        rollback;
      end if;
      resignal set message_text = @errstr;
    end if;
  end if;
end;

XXX: repeat

if @@in_transaction then
  set lastSqlCode = 20002;
  set lastMsgTxt = 'Cannot run inside an already opened tran';
  leave XXX;
end if;

-- Validate

set transaction isolation level Read Committed;

start transaction read only;

if exists (
  select 1
  from Env_CurBlock
  where BlockDtm = p_BlockDtm
     or BlockHash = p_BlockHash
  )
then
  set lastSqlCode = 10000;
  set lastMsgTxt = 'Env_CurBlock has already been recorded';
  leave XXX;
end if;

commit;

-- Execute

set transaction isolation level Serializable;

start transaction;

if exists (
  select 1
  from Env_CurBlock
  where BlockDtm = p_BlockDtm
     or BlockHash = p_BlockHash
  )
then
  set lastSqlCode = 10000;
  set lastMsgTxt = 'Env_CurBlock has already been recorded';
  leave XXX;
end if;

if p_BlockDtm < (select max(BlockDtm) from Env_CurBlock) then
  select 'Warn', chr(0x1f), concat('Env_CurBlock_Add_tr 01000 20001 ', 'BlockDtm travelling');
end if;

set cont = true;

insert into Env_CurBlock(BlockHash, BlockDtm, Dtm)
  values (p_BlockHash, p_BlockDtm, p_Dtm);

if err then
  set lastSqlCode = 10001;
  set lastMsgTxt = 'Insert Env_CurBlock failed';
  leave XXX;
end if;

until 1 end repeat;

set cont = false;
if @@in_transaction then
  if lastSqlCode = 0 then
    commit;
  else
    rollback;
  end if;
end if;

set cont = false;
if lastSqlCode <> 0 then
  signal sqlstate '45100'
    set mysql_errno = lastSqlCode, message_text = lastMsgTxt;
end if;

end;